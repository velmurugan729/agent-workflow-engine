# app/tools.py

from typing import Callable, Dict, Any, List

ToolFunc = Callable[[Dict[str, Any]], Dict[str, Any]]

# Global registry: tool_name -> function
TOOLS: Dict[str, ToolFunc] = {}


def register_tool(name: str):
    """
    Decorator to register a function as a tool in the global registry.
    """
    def decorator(func: ToolFunc) -> ToolFunc:
        TOOLS[name] = func
        return func
    return decorator


def get_tool(name: str) -> ToolFunc:
    """
    Look up a tool by name from the registry.
    """
    if name not in TOOLS:
        raise ValueError(f"Tool '{name}' is not registered")
    return TOOLS[name]


# -------------------------------
# Example Agent Workflow:
# Summarization + Refinement
# -------------------------------

@register_tool("split_text")
def split_text_tool(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Split a long text into chunks.

    Expects:
      state["text"]        -> full text (str)
      state["chunk_size"]  -> max chars per chunk (int, optional, default=300)

    Produces:
      state["chunks"]      -> List[str]
    """
    text = state.get("text", "")
    chunk_size = int(state.get("chunk_size", 300))

    chunks: List[str] = []
    for i in range(0, len(text), chunk_size):
        chunks.append(text[i: i + chunk_size])

    state["chunks"] = chunks
    return state


@register_tool("generate_summaries")
def generate_summaries_tool(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Generate small summaries for each chunk.

    Expects:
      state["chunks"]      -> List[str]

    Produces:
      state["summaries"]   -> List[str]

    Implementation detail:
      For simplicity, each "summary" is just the first 100 characters
      of the chunk (rule-based, no ML).
    """
    chunks: List[str] = state.get("chunks", [])
    summaries = [chunk[:100].strip() for chunk in chunks]
    state["summaries"] = summaries
    return state


@register_tool("merge_summaries")
def merge_summaries_tool(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Merge individual chunk summaries into a single summary.

    Expects:
      state["summaries"] -> List[str]

    Produces:
      state["summary"]   -> str
    """
    summaries: List[str] = state.get("summaries", [])
    merged = " ".join(summaries)
    state["summary"] = merged
    return state


@register_tool("refine_summary")
def refine_summary_tool(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Refine or shorten the final summary.

    Expects:
      state["summary"]            -> current summary text (str)
      state["max_summary_length"] -> max length allowed (int, optional, default=400)

    Produces:
      state["summary"]            -> refined summary (str)

    If the summary is too long, we trim it to max length and cut on a word boundary.
    """
    summary: str = state.get("summary", "")
    max_len = int(state.get("max_summary_length", 400))

    if len(summary) > max_len:
        summary = summary[:max_len].rsplit(" ", 1)[0]

    state["summary"] = summary
    return state






